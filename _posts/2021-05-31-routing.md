---
layout: post
title: "Der Technische Aufbau unseres Lastenrad Routing"
author: Henri Chilla
excerpt: "Wie wir unser Lastenrad-Routing gebaut haben."
description: "Wie wir unser Lastenrad-Routing gebaut haben."
---

<img alt="Header Image mit CargoRocket Logo und Frau auf Lastenrad auf Route" src="/assets/posts/routing-header-image.png" style="max-width: 100%;" />

Für jede Person, die Wissen möchten, wie wir GraphHopper verwendet haben um ein Lastenrad Routing zu realisieren, könnte dieser Artikel interessant sein.

Wir beschreiben, wie wir GraphHopper angepasst haben und wie wir unseren CargoBikeIndex in das Routing integriert haben. Aber auch, auf welche Probleme wir gestoßen sind.

Wir verwenden für das Routing ausschließlich OpenStreetMap Daten und Höheninformationen (CGIAR) und machen teils Data-Preprocessing vor dem Import in unsere GraphHopper Instanz.


## GraphHopper

Für unser Routing verwenden wir eine angepasste Version von <a href="https://www.graphhopper.com/">GraphHopper</a>. GraphHopper ist eine Open-Source Routing Engine und kann darüber hinaus auch noch vieles mehr (bspw. Isochrone berechnen). Der Code ist offen auf unserem [GitHub Account](https://github.com/CargoRocket/CargoHopper).

![GraphHopper Logo](/assets/posts/graphhopper-logo.png)

GraphHopper bietet eine gute, fertige API, die unter anderem auch Zwischenziele, Custom Routing Profile oder Alternative Routen anbietet. Vor allem nützlich für uns war jedoch die "Path Details" funktion, welche angegebene Attribute von Wegen (in der Regel aus OpenStreetMap) zurückgeben kann. Dies erfordert allerdings gewisse Vorraussetzungen (Stichwort "Encoded Values").

In GraphHopper existieren darüberhinaus verschiedene vorgefertigte, sogenannte Routing Profile. Diese stehen unter anderem für Wandern, LKW oder eben Fahrräder zur Verfügung. Für unsere Zwecke erstellten wir also eine Cargobike Profil (in GraphHopper auch "Flag Encoder"), welches unsere erweiterten Daten verwendet und unsere eigene Gewichtung von Kanten verwendet. Dieses basiert auf dem Fahrrad Profil.

## Gewichtung der Kanten (Weighting)
Bevor eine Wegefindung stattfinden kann, ist die Gewichtung der einzelnen Kanten eines Graphen notwendig. Ausgehend vom "Fahrrad Profil" beziehen wir noch unseren CargoBikeIndex mithinzu. Das Fahrrad Profil betrachtet bereits Einschränkungen bzw. Explizite Erlaubnisse wie Fahren gegen die Einbahnstraße für Radfahrende erlaubt (Verkehrszeichen 267 <img src="/assets/posts/Zeichen-Verbot_der_Einfahrt.svg" height="25" /> mit StVO Zusatzzeichen 1022-10 <img src="/assets/posts/Zusatzzeichen-Radfahrer_frei.svg" height="25" />) oder Fahren auf der Fahrbahn verboten (Verkehrszeichen 254 <img src="/assets/posts/Zeichen-Verbot_für_Radfahrer.svg" height="25" />). Außerdem verwendet es beschilderte Routen, welche in OpenStreetMap eingetragen sind.

Der CargoBikeIndex [CBI] bewertet von 0 (nicht passierbar) bis 5 (optimal für Lastenräder) Straßen und Wege. Diese Gewichtung wird derzeit durch einen Natürlichen Logarithmus miteinbezogen. Das bedeutet folgendes: Basierend auf dem Fahrradprofil erhalten Straßen & Wege, die einen CBI von 5 haben eine bessere Gewichtung erhalten, und Wege mit einem CBI von 1 etwa doppelt so schlecht bewertet werden. Dementsprechend haben Wege mit einer Bewertung von 0 ein unendliches Gewicht und werden somit nicht befahren.

## Preprocessing der OSM-Daten
Wir haben bereits [in diesem Blog Artikel](/2021/05/16/cargobikeindex.html) beschrieben, wie wir den CargoBikeIndex berechnen. Die OpenStreetMap Daten wurden hierfür in Form einer PBF Datei in eine PostgreSQL Datenbank mit [Osmosis](https://wiki.openstreetmap.org/wiki/Osmosis) geladen. In der Datenbank bewertet unser [R Skript](https://github.com/CargoRocket/OsmAnalysis) dann den CargoBikeIndex und schreibt diese in Form eines OSM-Tags zu dem entsprechenden Wegen, die grundsätzlich mit einem Fahrrad befahren werden können. Autobahnen werden also bspw. kategorisch ausgeschlossen. Dieses Datenbank Extrakt wird dann wiederum in GraphHopper geladen. Dieser erstellt dann den internen Graph.

## API
Der CargoBikeIndex wird als Encoded Value im Graph von GraphHopper gespeichert. Dadurch ist es möglich, dass die Route, welche von der API zurückgegeben wird dahingehend zu analysieren. So ist es bspw. möglich zusätzlich zu den Höheninformationen auch den CBI auf den einzelnen Straßen- und Wegeabschnitten nachzuvollziehen. Ein Debugging ist hiermit also auch teils möglich. Außerdem bietet GraphHopper einen eigene Vector Tiles (MVT), die die Encoded Values enthalten. Auch hiermit können einzelne Straßen und Wege nach ihren Attributen abgefragt werden. Zukünftig kann es so auch möglich sein potentielle Problemstellen auf der Route von Radfahrenden in der App anzuzeigen.

## Problematiken
Es gibt derzeit noch Problemstellungen, welche wir noch nicht mit GraphHopper lösen konnten. Diese Informationen wären jedoch wichtig füe die Kantengewichtung und somit für ein verbessertes Lastenradrouting. Diese Probleme sollen nun im Folgenden etwas erklärt werden.

### Node Tags
Derzeit ist es mit GraphHopper noch nicht möglich Attribute von Nodes allgemein oder im speziellen zusätzliche Attribute von Barrieren auszuwerten. Interessant ist das bspw. für die Höhe von Bordsteinen, oder `maxwidth` Tags für Breiten von Pollern. Es ist nur festzustellen ob eine Barriere vorhanden ist oder nicht.

### Kanten in Flächen
Wir wissen, dass Radfahren vor allem in grüner Umgebung attraktiv ist. Dies gilt natürlich auch für die Lastenradfahrende. Allerdings ist es in GraphHopper nicht möglich Straßen und Wege, welche bspw. in Parks liegen, besser zu bewerten. Das ist nachvollziehbar, da dann das erstellen des Graphen deutlich verlängern würde. Daher werden wir hierfür eine alternative Lösung finden.

## Weitere Infos
Unser Routing ist bald in unserer Smartphone App für jede Person frei testbar. Feedback ist immer willkommen. Wir freuen uns über jede Nachricht.
